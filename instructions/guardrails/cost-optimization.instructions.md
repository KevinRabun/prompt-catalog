---
name: Cost Optimization Guardrails
description: Ensure AI agents consider cost implications in both AI usage and software being built
---

<!-- Catalog Metadata
id: INST-GUARD-003
version: 1.0.0
scope: guardrail
applies_to: all
priority: high
author: community
last_reviewed: 2026-02-12
-->

# Cost Optimization Guardrails

## Objective
AI-assisted development has two cost dimensions: the **cost of using AI** (token consumption, API calls) and the **cost of the software being built** (infrastructure, licensing, operations). These guardrails address both.

## Part 1: Cost-Effective AI Usage

### Token Efficiency
- Be **concise and precise** in prompt responses — avoid unnecessary verbosity
- Return **relevant code**, not boilerplate that can be generated by scaffolding tools
- Use **incremental generation** — don't regenerate entire files for small changes
- Reuse **context** from previous exchanges rather than restating everything
- When possible, provide **targeted diffs** rather than complete file rewrites

### Prompt Design for Efficiency
- Structure prompts to get the right answer on the **first try**
- Include **sufficient context** to avoid back-and-forth
- Use **specific examples** so the AI doesn't have to guess at format
- Break complex tasks into **focused sub-tasks** rather than one massive prompt

### Avoid Wasteful Patterns
- Don't regenerate code that hasn't changed
- Don't request explanations when only code is needed (and vice versa)
- Don't use AI for tasks better handled by deterministic tools (formatting, linting)
- Don't repeat failed approaches — change strategy instead

## Part 2: Cost-Effective Software Design

### Cloud Resource Optimization

#### Compute
- **Right-size** instances — start small, scale based on metrics
- Use **auto-scaling** instead of provisioning for peak load
- Consider **spot/preemptible instances** for fault-tolerant workloads
- Use **serverless** for intermittent or unpredictable workloads
- Schedule **non-production environments** to shut down after hours
- Use **reserved instances/savings plans** for predictable, steady-state workloads

#### Storage
- Choose the right **storage tier** for the access pattern (hot, cool, archive)
- Implement **data lifecycle policies** — archive or delete old data automatically
- Use **appropriate data formats** — columnar for analytics, row-based for OLTP
- Compress data where appropriate
- Don't store derived data that can be cheaply recomputed

#### Networking
- Minimize **cross-region data transfer** — process data where it lives
- Use **CDNs** for static content to reduce origin load and bandwidth
- Batch API calls where possible to reduce request overhead
- Use **efficient serialization** (Protocol Buffers, MessagePack) for high-volume internal traffic

#### Database
- Choose the **right database** for the workload — don't use a relational DB for everything
- Use **connection pooling** to minimize connection overhead
- Design **efficient queries** — avoid N+1 queries, use appropriate indexes
- Consider **read replicas** instead of scaling up the primary
- Use **caching** for frequently accessed, slowly changing data
- Set up **provisioned throughput wisely** — understand your access patterns

### Licensing Considerations
- Prefer **open-source** when quality alternatives exist
- Understand **per-core, per-user, per-instance** licensing implications
- Consider **managed services vs. self-hosted** total cost (including operations)
- Factor in **egress costs** when choosing cloud services
- Watch for **vendor lock-in** that limits future optimization

### Operational Cost
- Automate **repetitive tasks** to reduce human operational cost
- Implement **self-healing** where possible to reduce incident response costs
- Use **managed services** where the operational overhead exceeds the cost premium
- Monitor and **optimize CI/CD pipeline costs** — long build times waste compute
- Right-size **monitoring and logging** — store what's useful, not everything

## Cost Awareness in Code

When generating architecture or infrastructure code:
```
1. Add comments noting cost implications of design choices
2. Include cost comparison when presenting alternatives
3. Flag potentially expensive operations (cross-region calls, large data transfers)
4. Suggest cost monitoring and alerting
5. Recommend tagging resources for cost attribution
```

### Example Cost Annotations
```yaml
# Cost consideration: This uses a Standard_D4s_v3 instance ($140/month).
# For dev/test, consider Standard_B2s ($30/month) which is burstable.

# Cost consideration: Cross-region replication adds ~$0.02/GB/month storage
# plus $0.02/GB egress. Evaluate if RPO requirements justify the cost.

# Cost consideration: This Cosmos DB configuration with 10,000 RU/s costs
# ~$580/month. Consider autoscale (scales 10%-100%) to save on variable loads.
```

## Cost Review Checklist

- [ ] Compute resources are right-sized for the workload
- [ ] Auto-scaling is configured with appropriate min/max
- [ ] Non-production resources have shutdown schedules
- [ ] Storage lifecycle policies are in place
- [ ] Database queries are efficient and indexed
- [ ] Caching strategy reduces unnecessary computation and I/O
- [ ] Data transfer costs are minimized (colocation, CDN, compression)
- [ ] Licensing implications are understood and documented
- [ ] Resource tagging enables cost attribution
- [ ] Cost alerts are configured for unexpected spending
- [ ] Reserved capacity is used for steady-state workloads
